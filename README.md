# Динамические структуры данных
Структурой данных описываеться способ представления или хранения данных в вашем компъютере. Структуры данных это фундаментальные вещи которые используються в нашем компе или мы пишим програмы используя готовые или пишим свои структуры данных для представления или хранения данных.

Структуры данных есть двух типов, это статические, т.е. память под которые выделяеться на момент создания этой структуры и ее размер не может меняться на протяжении жизни этой структуры. Второй способ это динамический, т.е. струтура изменяеться в процессе работы программы, т.е. рантайм.

## Массив
Это статический вид структуры данных, размер которого не может быть изменен на протяжении жизни массива. Идея массива это произвольный доступ к элементам массива за константное время, используя его идекс. Пример массива, это наша физическая память компъютера. Массивы хороши при добааления или удаления данных в конец массива, но не в середине или другом месте, т.к. при этом прийдеться все элементы сдвигать вперед или назад, в зависимости от типа действия. При перемещении происходит также копирование, что есть не очень хорошо если объекты довольно большие.

## Связанный список.
Это динамическое представления данных. Это как бы сказать обратное массиву. Данные в списке представленны ввиде ноды, которая содержит сами данные и указатель на следующую ноду и на предыдущую.
```cpp
struct Node {
  Node* prev;
  void* data;
  Node* next;
}
```

Приимущество этого типа структуры в ее размер можно менять динамически, происходит быстрая вставка  и удаления элемента, просто перемещая указатели. Но поиск элемента выполняеться не за константное время, т.е. вы не знаете индекс, т.к. его нет, и вам приходится перебрать все элементы от начала до конца.

Списки также бывают однонаправленные и двунаправленные.

## Стек
Стек это структура данных которая работает по принципу LIFO(last in first out). Со стеком мы сталкиваемся повсюду в наших программах. Пример это функция `main` которая ложиться на дно стека, а дальше по списку вызовов остальные фукнкции, и пока работает наша `main`, наша программа не завершит выполнение.

Стек ограничен своей фукнкциональностью, т.е. в него можно что то положить, вытолкнуть значение с очереди, и взять значение с вершины стека.

## Очередь
В противоположность стеку есть очередь, идея ее работает по принципу FIFO (first in first out). Т.е. как видим очередь есть противоположность стеку. Пример работы очередь, это обработка оконных сообщений вашего UI приложения. Т.е. если окно в данный момент не сможет обработать все сообщения, например окно залагало, то сообщение ложиться в очередь, а потом обрабатываеться.

## Очередь с приоритетом.
Это тоже что и обычная очередь, но сообщения обрабатываються с какимто например ключем который являеться понятием приоритета, т.е. сначало обрабатываеться приоритетное сообщение, а потом все остальные.

## Хеш таблица
Похож на массив, но вместо индексов используеться хеш хранимого значения. Например если у нас есть библиотека и нам необходимо взять эту книгу, то мы по имени книги дожны быстро взять эту книгу применив хеш к названию книги. Для вычесления хешей применяеться так называемые хеш функции, которые могут решать проблемы колизий имен и т.д.


